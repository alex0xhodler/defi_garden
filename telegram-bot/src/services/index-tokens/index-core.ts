import { Address, parseUnits } from 'viem';
import { getCoinbaseSmartWallet, createSponsoredBundlerClient, hasCoinbaseSmartWallet } from '../../lib/coinbase-wallet';
import { getWallet } from '../../lib/token-wallet';
import { 
  saveIndexPosition, 
  saveIndexTransaction, 
  getIndexPositionByUserAndToken,
  updateIndexPositionValue,
  getIndexTokenById 
} from '../../lib/database';
import { 
  IndexTransactionResult, 
  IndexToken, 
  IndexPosition 
} from '../../types/index-tokens';
import { 
  INDEX_CONTRACTS, 
  BASE_TOKENS,
  INDEX_ERRORS,
  INDEX_TRANSACTION_CONFIG 
} from '../../utils/index-constants';
import { getOdosQuote, buildSwapCalldata } from './odos-router';

/**\n * Buy index tokens using USDC\n * @param userId User ID\n * @param indexTokenId Index token ID from database\n * @param usdcAmount Amount in USDC to invest\n * @returns Transaction result\n */\nexport async function buyIndexToken(\n  userId: string,\n  indexTokenId: string,\n  usdcAmount: string\n): Promise<IndexTransactionResult> {\n  try {\n    console.log(`üõí Starting index token purchase: ${usdcAmount} USDC for ${indexTokenId}`);\n\n    // Validate inputs\n    const amount = parseFloat(usdcAmount);\n    if (amount < 1) {\n      return { success: false, error: INDEX_ERRORS.INVALID_AMOUNT };\n    }\n\n    // Get index token metadata\n    const indexToken = getIndexTokenById(indexTokenId);\n    if (!indexToken) {\n      return { success: false, error: INDEX_ERRORS.INVALID_INDEX_TOKEN };\n    }\n\n    // Check if user has Smart Wallet (required for gasless transactions)\n    if (!hasCoinbaseSmartWallet(userId)) {\n      return { success: false, error: INDEX_ERRORS.NO_SMART_WALLET };\n    }\n\n    // Get user's Smart Wallet\n    const smartWalletData = await getCoinbaseSmartWallet(userId);\n    if (!smartWalletData) {\n      return { success: false, error: INDEX_ERRORS.NO_SMART_WALLET };\n    }\n\n    const smartAccount = smartWalletData.smartAccount;\n    const usdcAmountWei = parseUnits(usdcAmount, 6); // USDC has 6 decimals\n\n    // Get quote from Odos Router\n    console.log('üìã Getting quote from Odos Router...');\n    const quoteResult = await getOdosQuote(\n      BASE_TOKENS.USDC, // Input token (USDC)\n      indexToken.contractAddress as Address, // Output token (Index token)\n      usdcAmountWei,\n      smartAccount.address\n    );\n\n    if (!quoteResult.success || !quoteResult.quote) {\n      return { success: false, error: quoteResult.error || INDEX_ERRORS.ODOS_API_ERROR };\n    }\n\n    const quote = quoteResult.quote;\n    const expectedTokens = BigInt(quote.outAmounts[0]);\n    const pricePerToken = parseFloat(usdcAmount) / (parseFloat(quote.outAmounts[0]) / 1e18); // Assuming 18 decimals for index tokens\n\n    console.log(`üí∞ Quote received: ${usdcAmount} USDC ‚Üí ${(Number(expectedTokens) / 1e18).toFixed(6)} ${indexToken.symbol}`);\n    console.log(`üí± Price per token: $${pricePerToken.toFixed(4)} USDC`);\n\n    // Check price impact\n    if (quote.priceImpact > 5.0) { // 5% price impact threshold\n      return { \n        success: false, \n        error: `${INDEX_ERRORS.SLIPPAGE_TOO_HIGH} Price impact: ${quote.priceImpact.toFixed(2)}%` \n      };\n    }\n\n    // Build transaction calldata\n    const approveCalldata = buildApproveCalldata(\n      BASE_TOKENS.USDC, \n      INDEX_CONTRACTS.ODOS_ROUTER_V3, \n      usdcAmountWei\n    );\n\n    // Execute gasless transaction\n    console.log('‚ö° Executing gasless transaction...');\n    const result = await executeGaslessIndexPurchase(\n      smartAccount,\n      approveCalldata,\n      quote.transaction.data,\n      quote.transaction.to\n    );\n\n    if (!result.success) {\n      return { success: false, error: result.error || INDEX_ERRORS.TRANSACTION_FAILED };\n    }\n\n    // Save transaction record\n    await saveIndexTransaction(\n      result.txHash!,\n      userId,\n      indexTokenId,\n      'buy',\n      parseFloat(usdcAmount),\n      parseFloat(quote.outAmounts[0]) / 1e18, // Convert to human readable\n      pricePerToken,\n      'success',\n      undefined // Gas used not available for sponsored transactions\n    );\n\n    // Update or create position\n    await updateUserPosition(\n      userId,\n      indexTokenId,\n      parseFloat(quote.outAmounts[0]) / 1e18, // Tokens received\n      parseFloat(usdcAmount), // USDC invested\n      pricePerToken\n    );\n\n    console.log(`‚úÖ Index token purchase completed: ${result.txHash}`);\n\n    return {\n      success: true,\n      txHash: result.txHash,\n      tokensReceived: (Number(expectedTokens) / 1e18).toFixed(6),\n      pricePerToken: pricePerToken\n    };\n\n  } catch (error: any) {\n    console.error('‚ùå Error buying index token:', error);\n    return {\n      success: false,\n      error: error.message || INDEX_ERRORS.TRANSACTION_FAILED\n    };\n  }\n}\n\n/**\n * Sell index tokens for USDC\n * @param userId User ID\n * @param indexTokenId Index token ID from database\n * @param tokenAmount Amount of index tokens to sell (or \"max\")\n * @returns Transaction result\n */\nexport async function sellIndexToken(\n  userId: string,\n  indexTokenId: string,\n  tokenAmount: string\n): Promise<IndexTransactionResult> {\n  try {\n    console.log(`üíµ Starting index token sale: ${tokenAmount} ${indexTokenId}`);\n\n    // Get index token metadata\n    const indexToken = getIndexTokenById(indexTokenId);\n    if (!indexToken) {\n      return { success: false, error: INDEX_ERRORS.INVALID_INDEX_TOKEN };\n    }\n\n    // Get user's position\n    const position = getIndexPositionByUserAndToken(userId, indexTokenId);\n    if (!position || position.tokensOwned <= 0) {\n      return { success: false, error: INDEX_ERRORS.POSITION_NOT_FOUND };\n    }\n\n    // Determine amount to sell\n    let sellAmount: number;\n    if (tokenAmount.toLowerCase() === 'max') {\n      sellAmount = position.tokensOwned;\n    } else {\n      sellAmount = parseFloat(tokenAmount);\n      if (sellAmount <= 0 || sellAmount > position.tokensOwned) {\n        return { success: false, error: INDEX_ERRORS.INSUFFICIENT_INDEX_TOKENS };\n      }\n    }\n\n    // Check if user has Smart Wallet\n    if (!hasCoinbaseSmartWallet(userId)) {\n      return { success: false, error: INDEX_ERRORS.NO_SMART_WALLET };\n    }\n\n    // Get user's Smart Wallet\n    const smartWalletData = await getCoinbaseSmartWallet(userId);\n    if (!smartWalletData) {\n      return { success: false, error: INDEX_ERRORS.NO_SMART_WALLET };\n    }\n\n    const smartAccount = smartWalletData.smartAccount;\n    const sellAmountWei = parseUnits(sellAmount.toString(), 18); // Assuming 18 decimals for index tokens\n\n    // Get quote from Odos Router (reverse swap)\n    console.log('üìã Getting sell quote from Odos Router...');\n    const quoteResult = await getOdosQuote(\n      indexToken.contractAddress as Address, // Input token (Index token)\n      BASE_TOKENS.USDC, // Output token (USDC)\n      sellAmountWei,\n      smartAccount.address\n    );\n\n    if (!quoteResult.success || !quoteResult.quote) {\n      return { success: false, error: quoteResult.error || INDEX_ERRORS.ODOS_API_ERROR };\n    }\n\n    const quote = quoteResult.quote;\n    const expectedUSDC = BigInt(quote.outAmounts[0]);\n    const pricePerToken = (parseFloat(quote.outAmounts[0]) / 1e6) / sellAmount; // USDC has 6 decimals\n\n    console.log(`üí∞ Sell quote received: ${sellAmount} ${indexToken.symbol} ‚Üí $${(Number(expectedUSDC) / 1e6).toFixed(2)} USDC`);\n    console.log(`üí± Price per token: $${pricePerToken.toFixed(4)} USDC`);\n\n    // Build transaction calldata\n    const approveCalldata = buildApproveCalldata(\n      indexToken.contractAddress as Address,\n      INDEX_CONTRACTS.ODOS_ROUTER_V3,\n      sellAmountWei\n    );\n\n    // Execute gasless transaction\n    console.log('‚ö° Executing gasless sell transaction...');\n    const result = await executeGaslessIndexPurchase(\n      smartAccount,\n      approveCalldata,\n      quote.transaction.data,\n      quote.transaction.to\n    );\n\n    if (!result.success) {\n      return { success: false, error: result.error || INDEX_ERRORS.TRANSACTION_FAILED };\n    }\n\n    const usdcReceived = Number(expectedUSDC) / 1e6;\n\n    // Save transaction record\n    await saveIndexTransaction(\n      result.txHash!,\n      userId,\n      indexTokenId,\n      'sell',\n      usdcReceived,\n      sellAmount,\n      pricePerToken,\n      'success'\n    );\n\n    // Update position\n    const newTokensOwned = position.tokensOwned - sellAmount;\n    if (newTokensOwned <= 0.000001) { // Dust threshold\n      // Delete position if selling all tokens\n      const { deleteIndexPosition } = await import('../../lib/database');\n      deleteIndexPosition(position.id);\n    } else {\n      // Update position with remaining tokens\n      const newTotalInvested = position.totalInvested * (newTokensOwned / position.tokensOwned);\n      const newCurrentValue = newTokensOwned * pricePerToken;\n      \n      updateIndexPositionValue(\n        position.id,\n        newTokensOwned,\n        newCurrentValue,\n        position.averageBuyPrice // Keep same average buy price\n      );\n    }\n\n    console.log(`‚úÖ Index token sale completed: ${result.txHash}`);\n\n    return {\n      success: true,\n      txHash: result.txHash,\n      tokensReceived: usdcReceived.toFixed(2), // USDC received\n      pricePerToken: pricePerToken\n    };\n\n  } catch (error: any) {\n    console.error('‚ùå Error selling index token:', error);\n    return {\n      success: false,\n      error: error.message || INDEX_ERRORS.TRANSACTION_FAILED\n    };\n  }\n}\n\n/**\n * Execute gasless transaction for index token operations\n * @param smartAccount Smart account instance\n * @param approveCalldata Approval transaction calldata\n * @param swapCalldata Swap transaction calldata\n * @param swapTarget Swap target address\n * @returns Transaction result\n */\nasync function executeGaslessIndexPurchase(\n  smartAccount: any,\n  approveCalldata: `0x${string}`,\n  swapCalldata: `0x${string}`,\n  swapTarget: Address\n): Promise<{ success: boolean; txHash?: string; error?: string }> {\n  try {\n    // Create sponsored bundler client\n    const bundlerClient = await createSponsoredBundlerClient(smartAccount);\n\n    // Prepare multicall operations\n    const operations = [\n      // Step 1: Approve token spending\n      {\n        to: approveCalldata.slice(0, 42) as Address, // Extract target address from calldata\n        value: 0n,\n        data: approveCalldata\n      },\n      // Step 2: Execute swap\n      {\n        to: swapTarget,\n        value: 0n,\n        data: swapCalldata\n      }\n    ];\n\n    // Execute sponsored UserOperation\n    const userOpHash = await bundlerClient.sendUserOperation({\n      account: smartAccount,\n      calls: operations\n    });\n\n    console.log(`‚è≥ UserOperation sent: ${userOpHash}`);\n\n    // Wait for transaction receipt\n    const receipt = await bundlerClient.waitForUserOperationReceipt({\n      hash: userOpHash,\n      timeout: INDEX_TRANSACTION_CONFIG.SWAP_TIMEOUT_MS\n    });\n\n    if (receipt.success) {\n      const actualTxHash = receipt.receipt.transactionHash;\n      console.log(`‚úÖ Transaction confirmed: ${actualTxHash}`);\n      return { success: true, txHash: actualTxHash };\n    } else {\n      return { success: false, error: 'Transaction failed during execution' };\n    }\n\n  } catch (error: any) {\n    console.error('‚ùå Gasless transaction failed:', error);\n    return {\n      success: false,\n      error: error.message || 'Gasless transaction execution failed'\n    };\n  }\n}\n\n/**\n * Build approve transaction calldata\n * @param tokenAddress Token to approve\n * @param spender Spender address (usually router)\n * @param amount Amount to approve\n * @returns Calldata string\n */\nfunction buildApproveCalldata(\n  tokenAddress: Address,\n  spender: Address,\n  amount: bigint\n): `0x${string}` {\n  // ERC20 approve function signature: approve(address,uint256)\n  const functionSelector = '0x095ea7b3';\n  \n  // Encode parameters\n  const spenderPadded = spender.slice(2).padStart(64, '0');\n  const amountPadded = amount.toString(16).padStart(64, '0');\n  \n  return `${functionSelector}${spenderPadded}${amountPadded}` as `0x${string}`;\n}\n\n/**\n * Update or create user's index position\n * @param userId User ID\n * @param indexTokenId Index token ID\n * @param tokensReceived New tokens received\n * @param usdcInvested USDC amount invested\n * @param currentPrice Current price per token\n */\nasync function updateUserPosition(\n  userId: string,\n  indexTokenId: string,\n  tokensReceived: number,\n  usdcInvested: number,\n  currentPrice: number\n): Promise<void> {\n  const existingPosition = getIndexPositionByUserAndToken(userId, indexTokenId);\n  \n  if (existingPosition) {\n    // Update existing position with new purchase\n    const newTotalTokens = existingPosition.tokensOwned + tokensReceived;\n    const newTotalInvested = existingPosition.totalInvested + usdcInvested;\n    const newAveragePrice = newTotalInvested / newTotalTokens;\n    const newCurrentValue = newTotalTokens * currentPrice;\n    \n    updateIndexPositionValue(\n      existingPosition.id,\n      newTotalTokens,\n      newCurrentValue,\n      newAveragePrice\n    );\n  } else {\n    // Create new position\n    const positionId = `idx_${Date.now()}_${userId}_${indexTokenId}`;\n    \n    saveIndexPosition({\n      id: positionId,\n      userId,\n      indexTokenId,\n      tokensOwned: tokensReceived,\n      averageBuyPrice: currentPrice,\n      totalInvested: usdcInvested,\n      currentValue: tokensReceived * currentPrice\n    });\n  }\n}\n\n/**\n * Get user's total index portfolio value\n * @param userId User ID\n * @returns Portfolio stats\n */\nexport async function getUserIndexPortfolioValue(userId: string): Promise<{\n  totalValue: number;\n  totalInvested: number;\n  totalPnL: number;\n  positionCount: number;\n}> {\n  try {\n    const { getIndexPortfolioStats } = await import('../../lib/database');\n    return getIndexPortfolioStats(userId);\n  } catch (error) {\n    console.error('Error getting index portfolio value:', error);\n    return {\n      totalValue: 0,\n      totalInvested: 0,\n      totalPnL: 0,\n      positionCount: 0\n    };\n  }\n}